#undef REALLOC
#undef Free
#undef ERROR
#include <dlib/global_optimization.h>
#undef REALLOC
#undef Free
#undef ERROR

#include "Inlassle.hpp"
#include "Field.hpp"
#include "Gaussian.hpp"
#include "ResistanceSolver.hpp"

// [[Rcpp::depends(RcppArmadillo,RcppParallel,BH,RcppEigen)]]

using dlib_colvec = dlib::matrix<double,0,1>;

struct ResistanceField
{
  //char covariance_model;//TODO not used
  const mat  counts,
             chromosomes,
             covariates;
  const vec  precision_dispersion,
             mean_dispersion;
  const bool parallel;
  const int  lipo_max;
  const bool verbose = true;
        bool derivatives = false;
      double delta_stop = 1e-4; // as all we're really interest in here is the objective, this can be quite high

  const uword n_spatial_parameters,
              n_variance_components,
              n_resistance_parameters;

  ResistanceSolver resistance;

  VectorXd diff_resistance;
  vec diff_spatial,
      diff_varcomp;

  ResistanceField (
               const mat& _counts, 
               const mat& _chromosomes, 
               const mat& _covariates, 
               const vec& _precision_dispersion, 
               const vec& _mean_dispersion, 
               const MatrixXi& _adjacency,
               const MatrixXd& _spatial_data,
               const UiVector& _targets,
               const int  _lipo_max = 100,
               const bool _parallel = false) :
    counts (arma::mat(_counts)),
    chromosomes (arma::mat(_chromosomes)),
    covariates (arma::mat(_covariates)),
    precision_dispersion (arma::mat(_precision_dispersion)),
    mean_dispersion (arma::mat(_mean_dispersion)),
    parallel (_parallel),
    lipo_max (_lipo_max),
    n_spatial_parameters (2),
    n_variance_components (covariates.n_cols),
    n_resistance_parameters (_spatial_data.cols()),
    resistance (_spatial_data, _targets, _adjacency, parallel),
    diff_spatial (arma::zeros<vec>(n_spatial_parameters)),
    diff_varcomp (arma::zeros<vec>(n_variance_components)),
    diff_resistance (VectorXd::Zero(n_resistance_parameters))
  {
    //TODO checks
  }

  Rcpp::List partial_model_dump (const vec& par, const cube& distances)
  { /* to get fitt'd field modes */
    // split parameters
    vec spatial_parameters (n_spatial_parameters + 1);
    vec variance_components (n_variance_components);

    uword i = 0;
    spatial_parameters(0) = 1;
    for (uword j=0; j<n_spatial_parameters; j++)
      spatial_parameters(j+1) = par(i++);
    for (uword j=0; j<n_variance_components; j++)
      variance_components(j) = par(i++);

    // trace -- DEBUG
    if (verbose)
    {
      i = 0;
      for (uword j=0; j<n_spatial_parameters; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
      for (uword j=0; j<n_variance_components; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
    }
    //

    /* Cholesky factor of random effects */
    mat L = arma::zeros<mat>(covariates.n_cols, covariates.n_cols);
    uword k = 0;
    for (uword i=0; i<covariates.n_cols; ++i)
      for (uword j=i; j<covariates.n_cols; ++j)
      {
        L(j,i) = variance_components(k);
        ++k;
      }

    /* assemble covariance */
    Gaussian cov (distances, spatial_parameters);
    mat field_covariance = cov.C + covariates*L*L.t()*covariates.t();

    // reject if covariance is not PD
    double logdet, logdet_sign;
    arma::log_det(logdet, logdet_sign, field_covariance);
    if (!(logdet_sign > 0.) || !arma::is_finite(logdet))
    {
      if (verbose)
        Rcpp::Rcout << std::setw(10) << "not PSD" << std::endl;
    }

    // calculate likelihood
    Field field (counts, chromosomes, field_covariance, covariates, precision_dispersion, mean_dispersion, parallel);

    // trace -- DEBUG
    if (verbose)
      Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(2) << field.lapapp << std::endl;
    //

    // copy derivative info, potentially needed later
    cube diff_distances = cov.dD.each_slice() % field.diff_covariance;
    diff_spatial = arma::sum(arma::sum(cov.dC.each_slice() % field.diff_covariance, 1), 0);
    diff_varcomp = covariates.t() * (field.diff_covariance + field.diff_covariance.t()) * covariates * L;

    return Rcpp::List::create(
        Rcpp::_["loglik"] = field.lapapp,
        Rcpp::_["field"] = field.mode_field,
        Rcpp::_["dispersion"] = field.mode_dispersion,
        Rcpp::_["fixef"] = field.mode_fixef,
        Rcpp::_["grad_spatial"] = diff_spatial,
        Rcpp::_["grad_varcomp"] = diff_varcomp,
        Rcpp::_["grad_distances"] = diff_distances);
  }

  double partial_model (const dlib_colvec& par, const cube& distances)
  {
    // split parameters
    vec spatial_parameters (n_spatial_parameters + 1);
    vec variance_components (n_variance_components);

    uword i = 0;
    spatial_parameters(0) = 1;
    for (uword j=0; j<n_spatial_parameters; j++)
      spatial_parameters(j+1) = par(i++);
    for (uword j=0; j<n_variance_components; j++)
      variance_components(j) = par(i++);

    // trace -- DEBUG
    if (verbose)
    {
      i = 0;
      for (uword j=0; j<n_spatial_parameters; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
      for (uword j=0; j<n_variance_components; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
    }
    //

    /* Cholesky factor of random effects */
    mat L = arma::zeros<mat>(covariates.n_cols, covariates.n_cols);
    uword k = 0;
    for (uword i=0; i<covariates.n_cols; ++i)
      for (uword j=i; j<covariates.n_cols; ++j)
      {
        L(j,i) = variance_components(k);
        ++k;
      }

    /* assemble covariance */
    Gaussian cov (distances, spatial_parameters);
    mat field_covariance = cov.C + covariates*L*L.t()*covariates.t();

    // reject if covariance is not PD
    double logdet, logdet_sign;
    arma::log_det(logdet, logdet_sign, field_covariance);
    if (!(logdet_sign > 0.) || !arma::is_finite(logdet))
    {
      if (verbose)
        Rcpp::Rcout << std::setw(10) << "not PSD" << std::endl;

      return arma::datum::inf;
    }

    // calculate likelihood
    Field field (counts, chromosomes, field_covariance, covariates, precision_dispersion, mean_dispersion, parallel);

    // trace -- DEBUG
    if (verbose)
      Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(2) << field.lapapp << std::endl;
    //

    // copy derivative info, potentially needed later
    if (derivatives)
    {
      diff_spatial = arma::sum(arma::sum(cov.dC.each_slice() % field.diff_covariance, 1), 0);
      diff_varcomp = covariates.t() * (field.diff_covariance + field.diff_covariance.t()) * covariates * L;
    }

    return field.lapapp;
  }

  double full_model (const dlib_colvec& par)
  {
    // split parameters
    vec spatial_parameters (n_spatial_parameters + 1);
    vec variance_components (n_variance_components);
    VectorXd resistance_parameters (n_resistance_parameters);

    uword i = 0;
    spatial_parameters(0) = 1;
    for (uword j=0; j<n_spatial_parameters; j++)
      spatial_parameters(j+1) = par(i++);
    for (uword j=0; j<n_variance_components; j++)
      variance_components(j) = par(i++);
    for (uword j=0; j<n_resistance_parameters; j++)
      resistance_parameters(j) = par(i++);

    // trace -- DEBUG
    if (verbose)
    {
      i = 0;
      for (uword j=0; j<n_spatial_parameters; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
      for (uword j=0; j<n_variance_components; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
      for (uword j=0; j<n_resistance_parameters; j++)
        Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(i++) << " ";
      Rcpp::Rcout << "|| ";
    }
    //

    // calculate resistance distance
    auto dist = resistance.resistance_distances (resistance_parameters);
    cube distances = arma::zeros<cube>(covariates.n_rows, covariates.n_rows, 1);
    for (uword i=0; i<covariates.n_rows; ++i)
      for (uword j=0; j<covariates.n_rows; ++j)
        distances(i,j,0) = dist(i,j);

    /* Cholesky factor of random effects */
    mat L = arma::zeros<mat>(covariates.n_cols, covariates.n_cols);
    uword k = 0;
    for (uword i=0; i<covariates.n_cols; ++i)
      for (uword j=i; j<covariates.n_cols; ++j)
      {
        L(j,i) = variance_components(k);
        ++k;
      }

    /* assemble covariance */
    Gaussian cov (distances, spatial_parameters);
    mat field_covariance = cov.C + covariates*L*L.t()*covariates.t();

    // reject if covariance is not PD
    double logdet, logdet_sign;
    arma::log_det(logdet, logdet_sign, field_covariance);
    if (!(logdet_sign > 0.) || !arma::is_finite(logdet))
    {
      if (verbose)
        Rcpp::Rcout << std::setw(10) << "not PSD" << std::endl;

      return arma::datum::inf;
    }

    // calculate likelihood
    Field field (counts, chromosomes, field_covariance, covariates, precision_dispersion, mean_dispersion, parallel);

    // trace -- DEBUG
    if (verbose)
      Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(2) << field.lapapp << std::endl;
    //

    // copy derivative info, potentially needed later
    if (derivatives)
    {
      diff_spatial = arma::sum(arma::sum(cov.dC.each_slice() % field.diff_covariance, 1), 0);
      diff_varcomp = covariates.t() * (field.diff_covariance + field.diff_covariance.t()) * covariates * L;
      cube diff_distances = cov.dD.each_slice() % field.diff_covariance;
      MatrixXd diff_distances_mat = MatrixXd::Zero(diff_distances.n_rows, diff_distances.n_cols);
      for (uword j=0; j<diff_distances_mat.rows(); ++j)
        for (uword k=0; k<diff_distances_mat.cols(); ++k)
          diff_distances_mat(j,k) = diff_distances.at(j,k,0);
      diff_resistance = resistance.rd_resistance_distances(diff_distances_mat);
    }

    return field.lapapp;
  }

  struct fit_model {
    ResistanceField &parent;
    fit_model (ResistanceField &parent) : parent(parent) {}
    double operator() (const dlib_colvec& par)
    {
      return parent.full_model(par);
    }
  };

  struct deriv_model {
    ResistanceField &parent;
    deriv_model (ResistanceField &parent) : parent(parent) {}
    dlib_colvec operator() (const dlib_colvec& par)
    {
      dlib_colvec grad;
      grad.set_size (par.size());

      uword i = 0;
      for (uword j=0; j<parent.n_spatial_parameters; j++)
        grad(i++) = parent.diff_spatial(j+1);
      for (uword j=0; j<parent.n_variance_components; j++)
        grad(i++) = parent.diff_varcomp(j);
      for (uword j=0; j<parent.n_resistance_parameters; j++)
        grad(i++) = parent.diff_resistance(j);

      return grad;
    }
  };

  struct fit_field {//THESE FUNCTORS CAN BE REPLACED BY LAMBDAS TODO
    ResistanceField &parent;
    const cube& distances;
    fit_field (ResistanceField &parent, const cube& distances) : parent(parent), distances(distances) {}
    double operator() (const dlib_colvec& par)
    {
      return parent.partial_model(par, distances);
    }
  };

  struct deriv_field {
    ResistanceField &parent;
    deriv_field (ResistanceField &parent) : parent(parent) {}
    dlib_colvec operator() (const dlib_colvec& par)
    {
      dlib_colvec grad;
      grad.set_size (par.size());

      uword i = 0;
      for (uword j=0; j<parent.n_spatial_parameters; j++)
        grad(i++) = parent.diff_spatial(j+1);
      for (uword j=0; j<parent.n_variance_components; j++)
        grad(i++) = parent.diff_varcomp(j);

      return grad;
    }
  };

  vec optimize (const vec lb, const vec ub)
  {
    derivatives = false;

    // convert arma to dlib
    dlib_colvec lower_bounds,
                upper_bounds;
    lower_bounds.set_size(lb.n_elem);
    upper_bounds.set_size(ub.n_elem);
    for (uword i=0; i<lb.n_elem; ++i)
    {
      lower_bounds(i) = lb(i);
      upper_bounds(i) = ub(i);
    }

    // optimize
    fit_model fitter (*this);
    auto result = dlib::find_min_global (
                                        fitter,
                                        lower_bounds,
                                        upper_bounds,
                                        dlib::max_function_calls(lipo_max));

    vec out (lb.n_elem+1);
    out(0) = result.y;
    for (uword i=1; i<lb.n_elem+1; ++i)
      out(i) = result.x(i-1);
    return out;
  }

  Rcpp::List profile (const vec& lb, const vec& ub, const vec& st)
  {

    // split bounds into two
    dlib_colvec lbo, ubo; 
    lbo.set_size (n_resistance_parameters);
    ubo.set_size (n_resistance_parameters);
    vec lbi (n_variance_components + n_spatial_parameters);
    vec ubi (n_variance_components + n_spatial_parameters);
    vec sti (n_variance_components + n_spatial_parameters);

    // copy arma -> dlib
    uword i=0;
    for (uword j=0; j<n_variance_components + n_spatial_parameters; ++j)
    {
      lbi(j) = lb(i);
      sti(j) = st(i);
      ubi(j) = ub(i++);
    }
    for (uword j=0; j<n_resistance_parameters; ++j)
    {
      lbo(j) = lb(i);
      ubo(j) = ub(i++);
    }

    // lambda defining inner optimization loop
    vec best_iter(1); vec current_iter; best_iter(0) = arma::datum::inf;
    auto ff = [&, sti](const dlib_colvec& par)
    {
      // DEBUG -- trace
      if (verbose)
      {
        Rcpp::Rcout << "********|| ";
        for (uword j=0; j<n_resistance_parameters; j++)
          Rcpp::Rcout << std::fixed << std::setw(10) << std::setprecision(3) << par(j) << " ";
        Rcpp::Rcout << "||*******" << std::endl;
      }

      // transfer to Eigen format
      VectorXd resistance_parameters (n_resistance_parameters);
      for (uword j=0; j<n_resistance_parameters; j++)
        resistance_parameters(j) = par(j);

      // calculate resistance distance
      auto dist = resistance.resistance_distances (resistance_parameters);
      cube distances = arma::zeros<cube>(covariates.n_rows, covariates.n_rows, 1);
      for (uword i=0; i<covariates.n_rows; ++i)
        for (uword j=0; j<covariates.n_rows; ++j)
          distances(i,j,0) = dist(i,j);

      // check if covariance matrix is valid at starting point
      dlib_colvec initp; initp.set_size(sti.n_elem);
      for (uword i=0; i<sti.n_elem; i++) initp(i) = sti(i);
      double init = partial_model(initp, distances);
      if (!arma::is_finite(init)) return arma::datum::inf;

      // optimize with distances
      current_iter = optimize_bfgs (lbi, ubi, sti, distances);

      // DEBUG -- trace
      if (verbose)
      {
        // NOT NEEDED, right?
      }

      if (current_iter(0) < best_iter(0)) best_iter = current_iter; // track best estimates

      return current_iter (0);
    };

    auto result = dlib::find_min_global (
                                        ff,
                                        lbo,
                                        ubo,
                                        dlib::max_function_calls(lipo_max));

    // copy dlib -> arma
    vec out (lbo.size()+1);
    out(0) = result.y;
    for (uword i=1; i<lbo.size()+1; ++i)
      out(i) = result.x(i-1);

    return Rcpp::List::create(Rcpp::_["spatial"] = best_iter,
                              Rcpp::_["resist"] = out);
  }

  vec optimize_bfgs (const vec lb, const vec ub, const vec st)
  {
    derivatives = true;

    // convert arma to dlib
    dlib_colvec start,
                lower_bounds,
                upper_bounds;
    lower_bounds.set_size(lb.n_elem);
    upper_bounds.set_size(ub.n_elem);
    start.set_size(st.n_elem);
    for (uword i=0; i<st.n_elem; ++i)
    {
      start(i) = st(i);
      lower_bounds(i) = lb(i);
      upper_bounds(i) = ub(i);
    }

    // optimize
    fit_model fitter (*this);
    auto ff = [&](const dlib_colvec& p) { return fitter(p); };
    deriv_model deriver (*this);
    auto fg = [&](const dlib_colvec& p) { return deriver(p); };
    auto result = dlib::find_min_box_constrained (
        dlib::bfgs_search_strategy(),
        dlib::objective_delta_stop_strategy(delta_stop),
        ff,
        fg,
        start,
        lower_bounds,
        upper_bounds);

    vec out (lb.n_elem+1);
    out(0) = result;
    for (uword i=1; i<lb.n_elem+1; ++i)
      out(i) = start(i-1);
    return out;
  }

  vec optimize_bfgs (const vec lb, const vec ub, const vec st, const cube& distances)
  {
    derivatives = true;

    // convert arma to dlib
    dlib_colvec start,
                lower_bounds,
                upper_bounds;
    lower_bounds.set_size(lb.n_elem);
    upper_bounds.set_size(ub.n_elem);
    start.set_size(st.n_elem);
    for (uword i=0; i<st.n_elem; ++i)
    {
      start(i) = st(i);
      lower_bounds(i) = lb(i);
      upper_bounds(i) = ub(i);
    }

    // optimize
    fit_field fitter (*this, distances);
    auto ff = [&](const dlib_colvec& p) { return fitter(p); };
    deriv_field deriver (*this);
    auto fg = [&](const dlib_colvec& p) { return deriver(p); };
    auto result = dlib::find_min_box_constrained (
        dlib::bfgs_search_strategy(),
        dlib::objective_delta_stop_strategy(delta_stop),
        ff,
        fg,
        start,
        lower_bounds,
        upper_bounds);

    vec out (lb.n_elem+1);
    out(0) = result;
    for (uword i=1; i<lb.n_elem+1; ++i)
      out(i) = start(i-1);
    return out;
  }

  vec optimize (const vec lb, const vec ub, const cube& distances)
  {
    // convert arma to dlib
    dlib_colvec lower_bounds,
                upper_bounds;
    lower_bounds.set_size(lb.n_elem);
    upper_bounds.set_size(ub.n_elem);
    for (uword i=0; i<lb.n_elem; ++i)
    {
      lower_bounds(i) = lb(i);
      upper_bounds(i) = ub(i);
    }

    // optimize
    fit_field fitter (*this, distances);
    auto result = dlib::find_min_global (
                                        fitter,
                                        lower_bounds,
                                        upper_bounds,
                                        dlib::max_function_calls(lipo_max));

    vec out (lb.n_elem+1);
    out(0) = result.y;
    for (uword i=1; i<lb.n_elem+1; ++i)
      out(i) = result.x(i-1);
    return out;
  }


};

// [[Rcpp::export]]
Rcpp::List run_partial (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::cube dis, const arma::vec par, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, 1, parallel);
  return model.partial_model_dump(par, dis);
}

// [[Rcpp::export]]
arma::vec run_lipo_full (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::vec lb, const arma::vec ub, int lipo_max = 100, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, lipo_max, parallel);
  vec out = model.optimize(lb, ub);
  return out;
}

// [[Rcpp::export]]
arma::vec run_bfgs_full (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::vec lb, const arma::vec ub, const arma::vec st, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, 1, parallel);
  vec out = model.optimize_bfgs(lb, ub, st);
  return out;
}

// [[Rcpp::export]]
arma::vec run_lipo_partial (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::cube dis, const arma::vec lb, const arma::vec ub, int lipo_max = 100, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, lipo_max, parallel);
  vec out = model.optimize(lb, ub, dis);
  return out;
}

// [[Rcpp::export]]
arma::vec run_bfgs_partial (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::cube dis, const arma::vec lb, const arma::vec ub, const arma::vec st, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, 1, parallel);
  vec out = model.optimize_bfgs(lb, ub, st, dis);
  return out;
}

// [[Rcpp::export]]
Rcpp::List run_lipo_profile (const arma::mat Y, const arma::mat N, const arma::mat X, const arma::vec Sp, const arma::vec Sm,
    const Eigen::MatrixXd Sd, const std::vector<unsigned> Tg, const Eigen::MatrixXi Ad, 
    const arma::vec lb, const arma::vec ub, const arma::vec st, int lipo_max = 100, bool parallel = false)
{
  ResistanceField model (Y, N, X, Sp, Sm, Ad, Sd, Tg, lipo_max, parallel);
  auto out = model.profile(lb, ub, st);
  return out;
}
